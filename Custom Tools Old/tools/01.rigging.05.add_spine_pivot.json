{
    "description": "",
    "type": "SIMPLE",
    "pie": {
        "enabled": false,
        "icon": "",
        "space": "Any Space"
    },
    "done": false,
    "undo_file": [
        "",
        ""
    ],
    "variables": [
        {
            "id": "8465",
            "name": "Chain Name",
            "type": "String",
            "description": "",
            "disappear_if": "",
            "disable_if": "",
            "emboss": true,
            "expand": false,
            "slider": false,
            "toggle": false,
            "separator": 0.0,
            "update_file": [
                "",
                ""
            ],
            "data": {
                "subtype": "NONE",
                "default": "Spine",
                "maxlen": 0
            }
        },
        {
            "id": "4519",
            "name": "Control Prefix",
            "type": "String",
            "description": "",
            "disappear_if": "",
            "disable_if": "",
            "emboss": true,
            "expand": false,
            "slider": false,
            "toggle": false,
            "separator": 0.0,
            "update_file": [
                "",
                ""
            ],
            "data": {
                "subtype": "NONE",
                "default": "CTL_",
                "maxlen": 0
            }
        },
        {
            "id": "5412",
            "name": "Opposite Prefix",
            "type": "String",
            "description": "",
            "disappear_if": "",
            "disable_if": "",
            "emboss": true,
            "expand": false,
            "slider": false,
            "toggle": false,
            "separator": 0.0,
            "update_file": [
                "",
                ""
            ],
            "data": {
                "subtype": "NONE",
                "default": "OPP_",
                "maxlen": 0
            }
        }
    ],
    "files": [
        [
            "ASP Code File 1.py",
            [
                "if bpy.context.mode == 'EDIT_ARMATURE':",
                "    if tool.opposite_prefix != tool.control_prefix:",
                "        if len(bpy.context.selected_editable_bones) >= 3:",
                "            pass",
                "        else:",
                "            self.report({'ERROR'}, message='Atleast Select 3 Bones')",
                "            return",
                "    else:",
                "        self.report({'ERROR'}, message='Control and Opposite Prefix Are Same')",
                "        return",
                "else:",
                "    self.report({'ERROR'}, message='Switch to Armature Edit Mode')",
                "    return",
                "",
                "def get_chain(bone, bones):",
                "    if bone.parent is not None and bone.parent in bones:",
                "        return get_chain(bone.parent, bones) + [bone]",
                "    else:",
                "        return [bone]",
                "",
                "def get_longest_chain(bone_list):",
                "    longest_chain = []",
                "    for bone in bone_list:",
                "        chain = get_chain(bone, bone_list)",
                "        if len(chain) > len(longest_chain):",
                "            longest_chain = chain",
                "    return longest_chain",
                "",
                "",
                "def make_name(prefix, remove_prefix_list, name):",
                "    for r_prefix in remove_prefix_list:",
                "        if r_prefix != '':",
                "            is_found = True",
                "            for idx in range(len(r_prefix)):",
                "                if name[idx].upper() != r_prefix[idx].upper():",
                "                    is_found = False",
                "                    break",
                "            if is_found:",
                "                new_name = name[idx+1:]",
                "                name = new_name",
                "                break",
                "    return prefix + name",
                "",
                "def make_bone_name(prefix, name, name_list, count=None):",
                "    remove_list = ['def_', 'tgt_', 'ndl_', 'ctl_']",
                "    remove_list.append(prefix)",
                "    new_prefix = prefix + ((str(count) + '_') if count is not None else '')",
                "    new_name = make_name(new_prefix, remove_list, name)",
                "    if new_name.upper() in name_list:",
                "        if count is None:",
                "            count = 1",
                "        else:",
                "            count = count + 1",
                "        return make_bone_name(prefix, name, name_list, count)",
                "    else:",
                "        return new_name",
                "",
                "",
                "def make_copy(bone_list, prefix):",
                "    if isinstance(bone_list, list) and len(bone_list) > 0:",
                "        armature = bone_list[0].id_data",
                "        name_list = [bone.name.upper() for bone in armature.edit_bones]",
                "        new_bone_list = []",
                "        for bone in bone_list:",
                "            new_bone = armature.edit_bones.new(make_bone_name(prefix, bone.name, name_list))",
                "            new_bone.use_deform = False",
                "            new_bone.length = bone.length",
                "            new_bone.matrix = bone.matrix",
                "            new_bone.use_connect = bone.use_connect",
                "            new_bone_list.append(new_bone)",
                "        for idx, new_bone in reversed(list(enumerate(new_bone_list))):",
                "            if idx > 0:",
                "                new_bone_list[idx].parent = new_bone_list[idx - 1]",
                "        return new_bone_list",
                "",
                "##################### START #########################",
                "",
                "",
                "",
                "",
                "selected_bones = bpy.context.selected_editable_bones",
                "target_bones = get_longest_chain(selected_bones)",
                "if len(target_bones) < len(selected_bones):",
                "    self.report({'ERROR'}, message='Selected Chain is Broken')",
                "    return",
                "",
                "target_count = len(target_bones)",
                "CHAIN_SIZE = sum([bone.length for bone in target_bones])",
                "AVG_SIZE = CHAIN_SIZE / target_count",
                "",
                "PIVOT_SIZE = AVG_SIZE * 0.8",
                "",
                "armature = bpy.context.object.data",
                "name_list = [bone.name.upper() for bone in armature.edit_bones]",
                "root_bone = target_bones[0]",
                "",
                "control_bones = make_copy(target_bones, tool.control_prefix)",
                "opposite_bones = make_copy(target_bones, tool.opposite_prefix)",
                "",
                "# PIVOT_NAME = 'Pivot_' + tool.chain_name",
                "pivot_bone = armature.edit_bones.new(make_bone_name('Pivot_', tool.chain_name, name_list))",
                "pivot_bone.use_deform = False",
                "pivot_bone.length = PIVOT_SIZE",
                "do_trans(pivot_bone, [",
                "    (",
                "        'Move',",
                "        ('Local', root_bone, None)",
                "    ),",
                "    (",
                "        'Rotate',",
                "        ('Global', root_bone, (0, 0, 180))",
                "    ),",
                "])",
                "",
                "for bone in control_bones:",
                "    do_trans(bone, [",
                "        (",
                "            'Move',",
                "            ('Global.Axis', bone, (0, 4, 0))",
                "        ),",
                "    ])",
                "",
                "bpy.ops.armature.select_all(action='DESELECT')",
                "for bone in opposite_bones:",
                "    bone.select = True",
                "    bone.select_head = True",
                "    bone.select_tail = True",
                "",
                "do_trans(opposite_bones, [",
                "    (",
                "        'Rotate',",
                "        ('Global.Axis', root_bone, (180, 0, 0))",
                "    ),",
                "])",
                "",
                "opp_bone_first = opposite_bones[0]",
                "",
                "change = get_change(opp_bone_first, do_trans(opp_bone_first, [",
                "    (",
                "        'Move',",
                "        ('Local', root_bone, None)",
                "    ),",
                "], 'As Matrix'))",
                "",
                "for bone in opposite_bones:",
                "    apply_change(change, bone)",
                "",
                "",
                "# Parenting Bones <-----",
                "",
                "",
                "for idx, ctl_bone in enumerate(control_bones):",
                "    opp_bone = opposite_bones[idx]",
                "    opp_bone.use_connect = False",
                "    opp_bone.parent = ctl_bone",
                "",
                "",
                "",
                "",
                "root_bone_name = root_bone.name",
                "pivot_bone_name = pivot_bone.name",
                "target_bone_name_list = [bone.name for bone in target_bones]",
                "control_bone_name_list = [bone.name for bone in control_bones]",
                "opposite_bone_name_list = [bone.name for bone in opposite_bones]",
                "",
                "",
                "bpy.ops.object.mode_set(mode='POSE')",
                "",
                "",
                "armature = bpy.context.object",
                "root_bone = armature.pose.bones[root_bone_name]",
                "pivot_bone = armature.pose.bones[pivot_bone_name]",
                "target_bones = [armature.pose.bones[name] for name in target_bone_name_list]",
                "opposite_bones = [armature.pose.bones[name] for name in opposite_bone_name_list]",
                "",
                "",
                "constraint_type = 'COPY_ROTATION'",
                "",
                "",
                "for idx, bone in enumerate(opposite_bones):",
                "    const = bone.constraints.new('COPY_LOCATION')",
                "    const.name = 'COPY_OPP_PREV_LOCATION'",
                "    const.target = armature",
                "    if idx == 0:",
                "        const.subtarget = pivot_bone.name",
                "    else:",
                "        const.subtarget = opposite_bones[idx - 1].name",
                "        const.head_tail = 1",
                "",
                "",
                "for idx, bone in enumerate(target_bones):",
                "    const = bone.constraints.new('COPY_ROTATION')",
                "    const.name = 'COPY_CTL_ROTATION'",
                "    const.target = armature",
                "    const.subtarget = control_bones[idx].name",
                "",
                "driver_constraints = []",
                "for idx, bone in enumerate(opposite_bones):",
                "    if idx == 0:",
                "        const = root_bone.constraints.new('COPY_LOCATION')",
                "        const.name = 'COPY_OPP_ROOT_LOCATION'",
                "    else:",
                "        const = root_bone.constraints.new('COPY_LOCATION')",
                "        const.name = f'COPY_OPP_B{idx}_LOCATION'",
                "        const.influence = 0",
                "        driver_constraints.append(const)",
                "    const.target = armature",
                "    const.subtarget = opposite_bones[idx].name",
                "",
                "const = root_bone.constraints.new('COPY_LOCATION')",
                "const.name = f'COPY_OPP_LEAF_LOCATION'",
                "const.target = armature",
                "const.subtarget = opposite_bones[-1].name",
                "const.head_tail = 1",
                "const.influence = 0",
                "driver_constraints.append(const)",
                "",
                "",
                "PROP_NAME = 'position'",
                "pivot_bone[PROP_NAME] = 0.0",
                "id_props = pivot_bone.id_properties_ui(PROP_NAME)",
                "id_props.update(",
                "    default=0.5,",
                "    min=0.0,",
                "    max=1.0,",
                "    soft_min=0.0,",
                "    soft_max=1.0,",
                ")",
                "",
                "",
                "",
                "# add a driver",
                "const_count = len(driver_constraints)",
                "for idx, const in enumerate(driver_constraints):",
                "    driver = armature.driver_add(f'pose.bones[\"{root_bone.name}\"].constraints[\"{const.name}\"].influence').driver",
                "    driver.type = 'SCRIPTED'",
                "    var = driver.variables.new()",
                "    var.name = 'var'",
                "    var.type = 'SINGLE_PROP'",
                "",
                "    var.targets[0].id = pivot_bone.id_data",
                "    var.targets[0].data_path = f'pose.bones[\"{pivot_bone.name}\"][\"{PROP_NAME}\"]'",
                "    driver.expression = f'var * {const_count} - {idx}'",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        ]
    ]
}